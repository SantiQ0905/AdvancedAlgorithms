# Analysis and Design of Advanced Algorithms 
# Group #607
# Team 3
# Luis Salomón Flores Ugalde

# Santiago Quintana Moreno A01571222
# Miguel Ángel Álvarez Hermida A01722925

# ------ HOMEWORK 14 PUZZLE SOLVER ------

import random
import itertools
import collections
import time

class Node:
    """
    A class representing an Solver node
    - 'puzzle' is a Puzzle instance see that move() creates a new puzzle depending on the move
    - 'parent' is the preceding node generated by the solver, if any
    - 'action' is the action taken to produce puzzle, if any
    """

    def __init__(self, puzzle, parent=None, action=None):
        self.puzzle = puzzle
        self.parent = parent
        self.action = action
        if parent:
            self.g = parent.g + 1
        else:
            self.g = 0


    def state(self):
        """
        Return a hashable representation of self
        """
        return str(self)

    def path(self):
        """
        Reconstruct path by walking back from current node to start
        """
        node, p = self, []
        while node:
            p.append(node)
            node = node.parent
        return p[::-1]

    def solved(self):
        """ Wrapper to check if 'puzzle' is solved """
        return self.puzzle.solved()

    def actions(self):
        """ Wrapper for 'actions' accessible at current state """
        return self.puzzle.actions()

    def h(self):
        """"Calculate h value using Manhattan distance heuristic"""
        return self.puzzle.manhattan()

    def f(self):
        """
        Return f(n) = g(n) + h(n) for A*.
        """
        return self.g + self.h()

    def __str__(self):
        return str(self.puzzle)


class Solver:
    """
      '8-puzzle' solver
      - 'start' is a Puzzle instance
     """

    def __init__(self, start):
        self.start = start

    def solve(self):
        queue = collections.deque([Node(self.start)])
        seen = set()
        seen.add(queue[0].state())
        
        while queue:
            queue = collections.deque(sorted(queue, key=lambda node: node.f()))
            node = queue.popleft()
            
            if node.solved():
                return node.path()

            for move, action in node.actions():
                child = Node(move(), node, action)
                
                if child.state() not in seen:
                    queue.append(child)
                    seen.add(child.state())


class Puzzle:
    """
    A class representing an '8-puzzle'.
    - 'board' should be a square list of lists with integer entries 0...width^2 - 1
       e.g. [[1,2,3],[4,0,6],[7,5,8]]
    - 'goal_state' is another board in the same format.
    """

    def __init__(self, board, goal_state=None):
        self.width = len(board[0])
        self.board = board

        # Default goal state
        if goal_state is None:
            self.goal = [[1, 2, 3],
                         [4, 5, 6],
                         [7, 8, 0]]
        else:
            self.goal = goal_state

        # Precompute goal positions for Manhattan
        self.goal_pos = {}
        for i in range(self.width):
            for j in range(self.width):
                v = self.goal[i][j]
                self.goal_pos[v] = (i, j)

    def solved(self):
        """
        The puzzle is solved if the current board equals the goal board.
        """
        return self.board == self.goal

    def actions(self):
        """
        Return a list of 'move', 'action' pairs. 'move' can be called
        to return a new puzzle that results in sliding the '0' tile in
        the direction of 'action'.
        """

        def create_move(at, to):
            return lambda: self._move(at, to)

        moves = []
        for i, j in itertools.product(range(self.width),
                                      range(self.width)):
            direcs = {'R': (i, j - 1),
                      'L': (i, j + 1),
                      'D': (i - 1, j),
                      'U': (i + 1, j)}

            for action, (r, c) in direcs.items():
                if 0 <= r < self.width and 0 <= c < self.width and self.board[r][c] == 0:
                    move = create_move((i, j), (r, c)), action
                    moves.append(move)
        return moves

    def manhattan(self):
        """
        Manhattan distance to the current goal_state.
        Uses goal_pos computed from self.goal.
        """
        distance = 0
        for i in range(self.width):
            for j in range(self.width):
                v = self.board[i][j]
                if v == 0:
                    continue  # usually ignore blank
                gi, gj = self.goal_pos[v]
                distance += abs(gi - i) + abs(gj - j)
        return distance


    def copy(self):
        """
        Return a new puzzle with the same board as 'self'
        """
        board = []
        for row in self.board:
            board.append([x for x in row])
        return Puzzle(board, goal_state=self.goal)

    def _move(self, at, to):
        """
        Return a new puzzle where 'at' and 'to' tiles have been swapped.
        NOTE: all moves should be 'actions' that have been executed
        """
        copy = self.copy()
        i, j = at
        r, c = to
        copy.board[i][j], copy.board[r][c] = copy.board[r][c], copy.board[i][j]
        return copy

    def pprint(self):
        for row in self.board:
            print(row)
        print()

    def __str__(self):
        return ''.join(map(str, self))

    def __iter__(self):
        for row in self.board:
            yield from row


board = [[1, 2, 3], [4, 5, 0], [6, 7, 8]]
goal_state = [[5, 7, 3], [1, 0, 8], [6, 2, 4]]
puzzle = Puzzle(board, goal_state)

s = Solver(puzzle)
tic = time.perf_counter()
p = s.solve()
toc = time.perf_counter()

steps = 0
for node in p:
    print(node.action)
    node.puzzle.pprint()
    steps += 1

print("Total number of steps: " + str(steps))
print("Total amount of time in search: " + str(toc - tic) + " second(s)")

